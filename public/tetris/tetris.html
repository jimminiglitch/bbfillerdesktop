<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SPACEWARDRIS.EXE</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg-opacity: .6;
      --font-main: 'Press Start 2P', monospace;
      --font-ui: 'VT323', monospace;
      --ui-color: #0ff;
      --overlay-bg: rgba(0,0,0,.85);
      --border-color: #fffc00;
      --rainbow-border: conic-gradient(
        red,orange,yellow,green,cyan,blue,magenta,red
      );
      --grid-size: 24;
      --star-count: 150;
      --cols: 10;
      --rows: 20;
    }
    * { margin:0; padding:0; box-sizing:border-box; }
    html,body {
      width:100%; height:100%;
      background: rgba(0,0,0,var(--bg-opacity));
      overflow:hidden;
      font-family: var(--font-main);
    }
    .overlay {
      position:fixed; inset:0;
      background: var(--overlay-bg);
      display:flex; flex-direction:column;
      align-items:center; justify-content:center;
      color:#fff; text-align:center;
      z-index:100;
    }
    .overlay.hidden { display:none; }
    .overlay h1 {
      color: var(--ui-color);
      text-shadow: 0 0 8px var(--ui-color);
      margin-bottom:1rem;
    }
    .overlay button {
      font-size:.9rem; padding:.5rem 1rem;
      border:2px solid var(--border-color);
      background:rgba(0,0,0,.7);
      color:var(--border-color);
      cursor:pointer;
      transition: transform .2s, border-color .2s;
    }
    .overlay button:hover {
      transform: scale(1.05);
      border-color: var(--ui-color);
    }
    #game-field {
      position:absolute;
      width:calc(var(--cols)*var(--grid-size)*1px);
      height:calc(var(--rows)*var(--grid-size)*1px);
      top:50%; left:50%;
      transform: translate(-50%,-50%);
      background:transparent;
    }
    #game-field::before {
      content:'';
      position:absolute; inset:-4px;
      border:4px solid transparent;
      border-image: var(--rainbow-border) 1;
      pointer-events:none;
    }
    #tetris-canvas {
      width:100%; height:100%; display:block;
    }
    #tetris-ui {
      position:absolute;
      top:20px; left:50%;
      transform:translateX(-50%);
      background:rgba(0,0,0,.4);
      padding:6px 10px;
      border:1px solid var(--ui-color);
      border-radius:4px;
      color:#fff;
      font-family: var(--font-ui);
      font-size:.8rem;
      text-shadow:0 0 6px var(--ui-color);
      z-index:10;
    }
    #tetris-ui span { margin-right:12px; }
    #mute-button {
      position:absolute;
      top:20px; right:30px;
      font-size:1.2rem; padding:4px;
      border:1px solid #f3a1ff;
      border-radius:4px;
      background:rgba(0,0,0,.4);
      color:#f3a1ff;
      cursor:pointer;
      text-shadow:0 0 6px #f3a1ff;
      transition: all .2s;
      z-index:10;
    }
    #mute-button:hover {
      transform:scale(1.1);
      border-color: var(--ui-color);
      color: var(--ui-color);
    }
  </style>
</head>
<body>
  <main id="game-container">
    <section id="start-overlay" class="overlay">
      <h1>SPACEWARDRIS.EXE</h1>
      <button type="button" data-action="start">CLICK TO START</button>
    </section>
    <section id="game-over-overlay" class="overlay hidden">
      <h1>GAME OVER</h1>
      <p>Your score: <span id="final-score">0</span></p>
      <button type="button" data-action="restart">PLAY AGAIN</button>
    </section>
    <div id="game-field">
      <canvas id="tetris-canvas"></canvas>
    </div>
    <div id="tetris-ui">
      <span data-ui="score">Score: 0</span>
      <span data-ui="lines">Lines: 0</span>
      <span data-ui="level">Level: 1</span>
      <span data-ui="status">Running</span>
    </div>
    <button type="button" id="mute-button" aria-label="Mute/Unmute">ðŸ”Š</button>
    <audio
      id="tetris-music"
      src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-6.mp3"
      loop preload="auto"
    ></audio>
  </main>
  <script>
    const querySelectorShortcut = s => document.querySelector(s);

    class TetrisGame {
      constructor() {
        this.startOvl    = querySelectorShortcut('#start-overlay');
        this.gameOverOvl = querySelectorShortcut('#game-over-overlay');
        this.finalScore  = querySelectorShortcut('#final-score');
        this.canvas      = querySelectorShortcut('#tetris-canvas');
        this.ctx         = this.canvas.getContext('2d');
        this.ui          = {
          score: querySelectorShortcut('[data-ui="score"]'),
          lines: querySelectorShortcut('[data-ui="lines"]'),
          level: querySelectorShortcut('[data-ui="level"]'),
          status:querySelectorShortcut('[data-ui="status"]'),
        };
        this.music   = querySelectorShortcut('#tetris-music');
        this.muteBtn = querySelectorShortcut('#mute-button');

        const style = getComputedStyle(document.documentElement);
        this.GRID       = +style.getPropertyValue('--grid-size');
        this.COLS       = +style.getPropertyValue('--cols');
        this.ROWS       = +style.getPropertyValue('--rows');
        this.STAR_COUNT = +style.getPropertyValue('--star-count');

        // The `SHAPES` object defines the Tetris pieces and their structures.
        // Each shape is represented as a 2D array where:
        // - Non-zero values indicate the presence of a block.
        // - The numbers correspond to different colors for each shape.
        // Shapes include:
        // - I: A straight line.
        // - J: A J-shaped piece.
        // - L: An L-shaped piece.
        // - O: A square block.
        // The COLORS array maps shape types (1-7) to their respective colors:
        // 1: Cyan (I), 2: Blue (J), 3: Orange (L), 4: Yellow (O),
        // 5: Green (S), 6: Purple (T), 7: Red (Z)
        this.SHAPES = {
          I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
          J: [[2,0,0],[2,2,2],[0,0,0]],
          L: [[0,0,3],[3,3,3],[0,0,0]],
          O: [[4,4],[4,4]],
          S: [[0,5,5],[5,5,0],[0,0,0]],
          T: [[0,6,0],[6,6,6],[0,0,0]],
          Z: [[7,7,0],[0,7,7],[0,0,0]]
        };
        this.COLORS = [
          null,'#00ffff','#0000ff','#ff7f00',
          '#ffff00','#00ff00','#800080','#ff0000'
        ];

        window.addEventListener('resize', debounce(() => this.resizeCanvas(), 200));
        this.grid  = this.createMatrix(this.COLS,this.ROWS);
        this.resetState();
        this.toggleMute = () => {
          this.music.muted = !this.music.muted;
          this.muteBtn.textContent = this.music.muted ? 'ðŸ”‡' : 'ðŸ”Š';
        };
        this.attachHandlers();
        this.lastTs = performance.now();
        this.resizeCanvas();
        requestAnimationFrame(ts => this.loop(ts));
      }

      clone(matrix) {
        return matrix.map(row => row.slice());
      }

      createMatrix(w, h) {
        const matrix = [];
        while (h--) matrix.push(new Array(w).fill(0));
        return matrix;
      }

      collide() {
        const {matrix, x, y} = this.piece;
        for (let r = 0; r < matrix.length; r++) {
          for (let c = 0; c < matrix[r].length; c++) {
            if (
              matrix[r][c] &&
              (
                y + r < 0 ||
                y + r >= this.ROWS ||
                x + c < 0 ||
                x + c >= this.COLS ||
                this.grid[y + r][x + c]
              )
            ) {
              return true;
            }
          }
        }
        return false;
      }

      attachHandlers() {
        document.addEventListener('keydown', e => {
          if (this.gameOver) return;
          switch (e.key) {
            case 'ArrowLeft':
              e.preventDefault();
              this.piece.x--;
              if (this.collide()) this.piece.x++;
              break;
            case 'ArrowRight':
              e.preventDefault();
              this.piece.x++;
              if (this.collide()) this.piece.x--;
              break;
            case 'ArrowDown':
              e.preventDefault();
              this.dropAcc += 50;
              break;
            case 'q':
              this.rotate(-1);
              break;
            case 'w':
              this.rotate(1);
              break;
            case 'p':
              this.paused = !this.paused;
              this.ui.status.textContent = this.paused ? 'Paused' : 'Running';
              this.paused ? this.music.pause() : this.music.play().catch(() => {});
              break;
          }
        });
        querySelectorShortcut('[data-action="start"]').addEventListener('click', () => {
          this.startOvl.classList.add('hidden');
          this.paused = false; this.music.play().catch(() => {});
        });
        querySelectorShortcut('[data-action="restart"]').addEventListener('click', () => {
          this.gameOverOvl.classList.add('hidden');
          this.resetState(); this.music.play().catch(() => {});
        });
        this.muteBtn.addEventListener('click', () => this.toggleMute());
      }

      resetState() {
        this.score = 0;
        this.lines = 0;
        this.level = 1;
        this.dropInterval = 1000;
        this.dropAcc = 0;
        this.gameOver = false;
        this.paused = false;
        this.grid.forEach(row => row.fill(0));
        this.spawnPiece();
        this.updateUI();
      }

      spawnPiece() {
        const types = Object.keys(this.SHAPES);
        this.piece = {
          matrix: this.clone(this.SHAPES[types[(types.length * Math.random()) | 0]]),
          x: ((this.COLS / 2) | 0) - 1,
          y: 0
        };
        if (this.collide()) {
          this.gameOver = true;
          this.ui.status.textContent = 'Game Over';
          this.gameOverOvl.classList.remove('hidden');
          this.finalScore.textContent = this.score;
          this.music.pause();
        }
      }

      sweep() {
        let rowCount = 0;
        outer: for (let y = this.ROWS - 1; y >= 0; y--) {
          for (let x = 0; x < this.COLS; x++) {
            if (this.grid[y][x] === 0) continue outer;
          }
          this.grid.splice(y, 1);
          this.grid.unshift(Array(this.COLS).fill(0));
          rowCount++;
          y++;
        }
        if (rowCount) {
          this.lines += rowCount;
          this.score += rowCount * 10 * this.level;
          this.dropInterval *= 0.9;
          if (this.lines >= this.level * 10) {
            this.level++;
            this.ui.level.textContent = `Level: ${this.level}`;
          }
          this.updateUI();
        }
      }

      initStars() {
        this.stars = Array.from({ length: this.STAR_COUNT }, () => {
          return {
            x: Math.random() * this.canvas.width,
            y: Math.random() * this.canvas.height,
            z: Math.random() * this.canvas.width,
            o: Math.random()
          };
        });
      }

      drawStars() {
        const ctx = this.ctx, cw = this.canvas.width, ch = this.canvas.height;
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, cw, ch);
        for (let s of this.stars) {
          s.o += (Math.random() - 0.5) * 0.02;
          s.o = Math.max(0.1, Math.min(1, s.o));
          s.z -= 2;
          if (s.z <= 0) {
            s.z = cw;
            s.x = Math.random() * cw;
            s.y = Math.random() * ch;
          }
          const k = 128 / s.z;
          const px = (s.x - cw / 2) * k + cw / 2;
          const py = (s.y - ch / 2) * k + ch / 2;
          const sz = Math.max(0.5, (1 - s.z / cw) * 2);
          ctx.globalAlpha = s.o;
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(px, py, sz, 0, 2 * Math.PI);
          ctx.fill();
        }
        ctx.globalAlpha = 1;
      }

      drawMatrix(matrix, offset) {
        matrix.forEach((row, y) => row.forEach((v, x) => {
          if (v) {
            this.ctx.fillStyle = this.COLORS[v];
            this.ctx.fillRect(
              (x + offset.x) * this.GRID,
              (y + offset.y) * this.GRID,
              this.GRID - 1, this.GRID - 1
            );
          }
        }));
      }

      draw() {
        if (this.gameOver) return;
        this.drawStars();
        this.grid.forEach((row, y) => row.forEach((v, x) => {
          if (v) {
            this.ctx.fillStyle = this.COLORS[v];
            this.ctx.fillRect(
              x * this.GRID,
              y * this.GRID,
              this.GRID - 1, this.GRID - 1
            );
          }
        }));
        this.drawMatrix(this.piece.matrix, { x: this.piece.x, y: this.piece.y });
      }

      update(delta) {
        if (this.gameOver || this.paused) return;
        this.dropAcc += delta;
        if (this.dropAcc > this.dropInterval) {
          this.piece.y++;
          if (this.collide()) {
            this.piece.y--;
            this.merge();
            this.sweep();
            this.spawnPiece();
          }
          this.dropAcc = 0;
        }
      }

      merge() {
        const { matrix, x, y } = this.piece;
        for (let r = 0; r < matrix.length; r++) {
          for (let c = 0; c < matrix[r].length; c++) {
            if (matrix[r][c]) {
              if (this.grid[y + r] && this.grid[y + r][x + c] !== undefined) {
                this.grid[y + r][x + c] = matrix[r][c];
              }
            }
          }
        }
      }

      updateUI() {
        this.ui.score.textContent = `Score: ${this.score}`;
        this.ui.lines.textContent = `Lines: ${this.lines}`;
        this.ui.level.textContent = `Level: ${this.level}`;
        this.ui.status.textContent = this.gameOver ? 'Game Over' : (this.paused ? 'Paused' : 'Running');
      }

      resizeCanvas() {
        this.canvas.width = this.canvas.clientWidth;
        this.canvas.height = this.canvas.clientHeight;
        this.initStars(); // Reinitialize stars after resizing
      }

      loop(ts) {
        const delta = ts - this.lastTs;
        this.lastTs = ts;
        this.update(delta);
        this.draw();
        requestAnimationFrame(ts => this.loop(ts));
      }

      rotate(dir) {
        const m = this.piece.matrix;
        // Transpose
        for (let y = 0; y < m.length; ++y) {
          for (let x = 0; x < y; ++x) {
            [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
          }
        }
        // Reverse rows for direction
        if (dir > 0) m.forEach(row => row.reverse());
        else m.reverse();
        if (this.collide()) {
          // Undo rotation if collision
          if (dir > 0) m.forEach(row => row.reverse());
          else m.reverse();
          for (let y = 0; y < m.length; ++y) {
            for (let x = 0; x < y; ++x) {
              [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
            }
          }
        }
      }
    }

    // Debounce utility function
    function debounce(fn, ms) {
      let timer;
      return function(...args) {
        clearTimeout(timer);
        timer = setTimeout(() => fn.apply(this, args), ms);
      };
    }

    // Wait for the DOM to fully load before initializing the Tetris game
    document.addEventListener('DOMContentLoaded', () => new TetrisGame());
  </script>
</body>
</html>
